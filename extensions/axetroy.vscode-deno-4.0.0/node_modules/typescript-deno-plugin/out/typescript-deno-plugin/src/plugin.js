"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const path = __importStar(require("path"));
const deepmerge_1 = __importDefault(require("deepmerge"));
const logger_1 = require("./logger");
const configuration_1 = require("../../core/configuration");
const deno_1 = require("../../core/deno");
const module_resolver_1 = require("../../core/module_resolver");
const deno_cache_1 = require("../../core/deno_cache");
const util_1 = require("../../core/util");
const deno_normalize_import_statement_1 = require("../../core/deno_normalize_import_statement");
const deno_deps_1 = require("../../core/deno_deps");
const ignoredCompilerOptions = [
    "allowSyntheticDefaultImports",
    "baseUrl",
    "build",
    "composite",
    "declaration",
    "declarationDir",
    "declarationMap",
    "diagnostics",
    "downlevelIteration",
    "emitBOM",
    "emitDeclarationOnly",
    "esModuleInterop",
    "extendedDiagnostics",
    "forceConsistentCasingInFileNames",
    "help",
    "importHelpers",
    "incremental",
    "inlineSourceMap",
    "inlineSources",
    "init",
    "isolatedModules",
    "listEmittedFiles",
    "listFiles",
    "mapRoot",
    "maxNodeModuleJsDepth",
    "module",
    "moduleResolution",
    "newLine",
    "noEmit",
    "noEmitHelpers",
    "noEmitOnError",
    "noLib",
    "noResolve",
    "out",
    "outDir",
    "outFile",
    "paths",
    "preserveSymlinks",
    "preserveWatchOutput",
    "pretty",
    "rootDir",
    "rootDirs",
    "showConfig",
    "skipDefaultLibCheck",
    "skipLibCheck",
    "sourceMap",
    "sourceRoot",
    "stripInternal",
    "target",
    "traceResolution",
    "tsBuildInfoFile",
    "types",
    "typeRoots",
    "version",
    "watch",
];
class DenoPlugin {
    constructor(typescript) {
        this.typescript = typescript;
        this.configurationManager = new configuration_1.Configuration();
        this.DEFAULT_OPTIONS = {
            allowJs: true,
            checkJs: false,
            strict: true,
            esModuleInterop: true,
            jsx: this.typescript.JsxEmit.React,
            module: this.typescript.ModuleKind.ESNext,
            moduleResolution: this.typescript.ModuleResolutionKind.NodeJs,
            outDir: "$deno$",
            resolveJsonModule: true,
            sourceMap: true,
            stripComments: true,
            target: this.typescript.ScriptTarget.ESNext,
            noEmit: true,
            noEmitHelpers: true,
        };
        this.MUST_OVERWRITE_OPTIONS = {
            jsx: this.DEFAULT_OPTIONS.jsx,
            module: this.DEFAULT_OPTIONS.module,
            moduleResolution: this.DEFAULT_OPTIONS.moduleResolution,
            resolveJsonModule: this.DEFAULT_OPTIONS.resolveJsonModule,
            strict: this.DEFAULT_OPTIONS.strict,
            noEmit: this.DEFAULT_OPTIONS.noEmit,
            noEmitHelpers: this.DEFAULT_OPTIONS.noEmitHelpers,
            target: this.typescript.ScriptTarget.ESNext,
        };
    }
    create(info) {
        var _a, _b;
        const { project, languageService, languageServiceHost } = info;
        const projectDirectory = project.getCurrentDirectory();
        function getRealPath(filepath) {
            return project.realpath ? project.realpath(filepath) : filepath;
        }
        process.chdir(projectDirectory);
        this.logger = logger_1.Logger.forPlugin(DenoPlugin.PLUGIN_NAME, info);
        this.logger.info(`Create typescript-deno-plugin`);
        const getCompilationSettings = languageServiceHost.getCompilationSettings.bind(languageServiceHost);
        const getScriptFileNames = languageServiceHost.getScriptFileNames.bind(languageServiceHost);
        const resolveModuleNames = (_a = languageServiceHost.resolveModuleNames) === null || _a === void 0 ? void 0 : _a.bind(languageServiceHost);
        const getSemanticDiagnostics = languageService.getSemanticDiagnostics.bind(languageService);
        const resolveTypeReferenceDirectives = (_b = languageServiceHost.resolveTypeReferenceDirectives) === null || _b === void 0 ? void 0 : _b.bind(languageServiceHost);
        const getCompletionEntryDetails = languageService.getCompletionEntryDetails.bind(languageService);
        languageServiceHost.getCompilationSettings = () => {
            const projectConfig = getCompilationSettings();
            if (!this.configurationManager.config.enable) {
                return projectConfig;
            }
            for (const option in projectConfig) {
                if (ignoredCompilerOptions.includes(option)) {
                    delete projectConfig[option];
                }
            }
            const compilationSettings = deepmerge_1.default(deepmerge_1.default(this.DEFAULT_OPTIONS, projectConfig), this.MUST_OVERWRITE_OPTIONS);
            return compilationSettings;
        };
        languageServiceHost.getScriptFileNames = () => {
            const scriptFileNames = getScriptFileNames();
            if (!this.configurationManager.config.enable) {
                return scriptFileNames;
            }
            const dtsFiles = [
                deno_1.getDenoDts(!!this.configurationManager.config.unstable),
            ];
            const iterator = new Set(dtsFiles).entries();
            for (const [, filepath] of iterator) {
                scriptFileNames.push(filepath);
            }
            return scriptFileNames;
        };
        if (resolveTypeReferenceDirectives) {
            languageServiceHost.resolveTypeReferenceDirectives = (typeDirectiveNames, containingFile, ...rest) => {
                if (!this.configurationManager.config.enable) {
                    return resolveTypeReferenceDirectives(typeDirectiveNames, containingFile, ...rest);
                }
                const realContainingFile = util_1.isUntitledDocument(containingFile)
                    ? path.join(project.getCurrentDirectory(), "untitled")
                    :
                        getRealPath(containingFile);
                if (!this.typescript.sys.fileExists(realContainingFile)) {
                    return [];
                }
                const importMapsFilepath = this.configurationManager.config.import_map
                    ? path.isAbsolute(this.configurationManager.config.import_map)
                        ? this.configurationManager.config.import_map
                        : path.resolve(project.getCurrentDirectory(), this.configurationManager.config.import_map)
                    : undefined;
                const resolver = module_resolver_1.ModuleResolver.create(realContainingFile, importMapsFilepath);
                const result = [];
                for (const typeDirectiveName of typeDirectiveNames) {
                    const [resolvedModule] = resolver.resolveModules([typeDirectiveName]);
                    if (resolvedModule) {
                        const target = {
                            primary: false,
                            resolvedFileName: resolvedModule.filepath,
                        };
                        result.push(target);
                        continue;
                    }
                    const [target] = resolveTypeReferenceDirectives([typeDirectiveName], containingFile, ...rest);
                    result.push(target);
                }
                return result;
            };
        }
        languageService.getSemanticDiagnostics = (filename) => {
            const diagnostics = getSemanticDiagnostics(filename);
            if (!this.configurationManager.config.enable) {
                return diagnostics;
            }
            const ignoredDiagnostics = [
                2306,
                1375,
                1103,
                2691,
                5009,
                5055,
                5070,
                7016,
            ];
            return diagnostics.filter((v) => !ignoredDiagnostics.includes(v.code));
        };
        languageService.getCompletionEntryDetails = (fileName, position, name, formatOptions, source, preferences) => {
            const details = getCompletionEntryDetails(fileName, position, name, formatOptions, source, preferences);
            if (!this.configurationManager.config.enable) {
                return details;
            }
            if (details) {
                const modifiers = details.kindModifiers.split(",") || [];
                if (modifiers.includes("export") &&
                    details.codeActions &&
                    details.codeActions.length) {
                    for (const ca of details.codeActions) {
                        for (const change of ca.changes) {
                            if (!change.isNewFile) {
                                for (const tc of change.textChanges) {
                                    tc.newText = deno_normalize_import_statement_1.normalizeImportStatement(fileName, tc.newText, this.logger);
                                }
                            }
                        }
                    }
                }
                if (details.source && details.source.length) {
                    for (const source of details.source) {
                        if (source.kind === "text") {
                            const text = source.text;
                            const absoluteFilepath = path.resolve(util_1.normalizeFilepath(path.dirname(fileName)), util_1.normalizeFilepath(text));
                            if (path.isAbsolute(absoluteFilepath)) {
                                const denoCache = deno_cache_1.CacheModule.create(absoluteFilepath, this.logger);
                                if (denoCache) {
                                    source.text = denoCache.meta.url.href;
                                }
                            }
                        }
                    }
                }
            }
            return details;
        };
        if (resolveModuleNames) {
            languageServiceHost.resolveModuleNames = (moduleNames, containingFile, ...rest) => {
                if (!this.configurationManager.config.enable) {
                    return resolveModuleNames(moduleNames, containingFile, ...rest);
                }
                const realContainingFile = util_1.isUntitledDocument(containingFile)
                    ? path.join(project.getCurrentDirectory(), "untitled")
                    :
                        getRealPath(containingFile);
                const importMapsFilepath = this.configurationManager.config.import_map
                    ? path.isAbsolute(this.configurationManager.config.import_map)
                        ? this.configurationManager.config.import_map
                        : path.resolve(project.getCurrentDirectory(), this.configurationManager.config.import_map)
                    : undefined;
                const resolver = module_resolver_1.ModuleResolver.create(realContainingFile, importMapsFilepath);
                const content = this.typescript.sys.readFile(containingFile, "utf8");
                if (content && content.indexOf("// @deno-types=") >= 0) {
                    const sourceFile = this.typescript.createSourceFile(containingFile, content, this.typescript.ScriptTarget.ESNext, true);
                    const modules = deno_deps_1.getImportModules(this.typescript)(sourceFile);
                    for (const m of modules) {
                        if (m.hint) {
                            const index = moduleNames.findIndex((v) => v === m.moduleName);
                            moduleNames[index] = m.hint.text;
                        }
                    }
                }
                const resolvedModules = resolver.resolveModules(moduleNames);
                for (const resolvedModule of resolvedModules) {
                    if (!resolvedModule) {
                        continue;
                    }
                    const content = this.typescript.sys.readFile(resolvedModule.filepath);
                    if (!content) {
                        continue;
                    }
                    const { typeReferenceDirectives } = this.typescript.preProcessFile(content, true, true);
                    if (!typeReferenceDirectives.length) {
                        continue;
                    }
                    const _resolver = module_resolver_1.ModuleResolver.create(resolvedModule.filepath, importMapsFilepath);
                    const modules = _resolver.resolveModules(typeReferenceDirectives.map((v) => v.fileName));
                    for (const m of modules) {
                        if (m) {
                            resolvedModule.origin = m.origin;
                            resolvedModule.filepath = m.filepath;
                        }
                    }
                }
                return resolvedModules.map((v) => {
                    if (!v) {
                        return v;
                    }
                    const result = {
                        extension: v.extension,
                        isExternalLibraryImport: false,
                        resolvedFileName: v.filepath,
                    };
                    return result;
                });
            };
        }
        this.configurationManager.resolveFromVscode(projectDirectory);
        this.configurationManager.onUpdatedConfig(() => {
            var _a;
            project.refreshDiagnostics();
            project.updateGraph();
            (_a = languageService.getProgram()) === null || _a === void 0 ? void 0 : _a.emit();
        });
        return languageService;
    }
    onConfigurationChanged(c) {
        this.logger.info(`onConfigurationChanged: ${JSON.stringify(c)}`);
        this.configurationManager.update(c);
    }
}
exports.DenoPlugin = DenoPlugin;
DenoPlugin.PLUGIN_NAME = "typescript-deno-plugin";
//# sourceMappingURL=plugin.js.map