"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const LCSof2usingDP_1 = require("./LCSof2usingDP");
const _intersection = require("lodash.intersection");
class BaseLCS {
    execute(sequences) {
        sequences = this.filterSequencesByIntersection(sequences);
        sequences = this.removeDuplicates(sequences);
        const cutHead = this.cutCommonHead(sequences);
        sequences = cutHead.sequencesWithoutHead;
        const cutTail = this.cutCommonTail(sequences);
        sequences = cutTail.sequencesWithoutTail;
        return [
            ...cutHead.commonHead,
            ...this.executeLCS(sequences),
            ...cutTail.commonTail
        ];
    }
    executeLCS(sequences) {
        if (sequences.some(s => s.length === 0))
            return [];
        switch (sequences.length) {
            case 0: return [];
            case 1: return sequences[0];
            case 2: return this.executeForTwo(sequences[0], sequences[1]);
            case 3: return this.executeForThree(sequences[0], sequences[1], sequences[2]);
            default: return this.executeForMoreThanThree(sequences);
        }
    }
    executeForThree(a, b, c) {
        //TODO: replace this implementation for the Dynamic Programming version for three sequences
        return this.executeForMoreThanThree([a, b, c]);
    }
    executeForTwo(a, b) {
        return LCSof2usingDP_1.lcs(a, b);
    }
    /**
     * Filter the sequences removing elements that aren't present in all sequences
     */
    filterSequencesByIntersection(sequences) {
        const intersection = new Set(_intersection(...sequences));
        return sequences.map(s => s.filter(e => intersection.has(e)));
    }
    /**
     * Remove repeated sequences
     */
    removeDuplicates(sequences) {
        const stringfiedSequences = sequences.map(s => JSON.stringify(s));
        const uniqueSequences = Array.from(new Set(stringfiedSequences));
        return uniqueSequences.map(s => JSON.parse(s));
    }
    cutCommonHead(sequences) {
        if (sequences[0].length) {
            const first = sequences[0][0];
            if (sequences.every(s => s.length > 0 && s[0] === first)) {
                var recursiveCut = this.cutCommonHead(sequences.map(s => s.slice(1)));
                return {
                    commonHead: [first, ...recursiveCut.commonHead],
                    sequencesWithoutHead: recursiveCut.sequencesWithoutHead
                };
            }
        }
        return {
            commonHead: [],
            sequencesWithoutHead: sequences
        };
    }
    cutCommonTail(sequences) {
        if (sequences[0].length) {
            const last = sequences[0][sequences[0].length - 1];
            if (sequences.every(s => s.length > 0 && s[s.length - 1] === last)) {
                var recursiveCut = this.cutCommonTail(sequences.map(s => s.slice(0, -1)));
                return {
                    commonTail: [...recursiveCut.commonTail, last],
                    sequencesWithoutTail: recursiveCut.sequencesWithoutTail
                };
            }
        }
        return {
            commonTail: [],
            sequencesWithoutTail: sequences
        };
    }
}
exports.default = BaseLCS;
//# sourceMappingURL=BaseLCS.js.map